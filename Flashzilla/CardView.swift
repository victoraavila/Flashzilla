//
//  CardView.swift
//  Flashzilla
//
//  Created by Víctor Ávila on 26/08/24.
//

import SwiftUI

// SwiftUI lets us attach custom gestures to any View, then lets us use the values generated by these gestures in other Views.
// We'll attach a Drag Gesture to our CardView so we can move it around the screen, and also use the generated values to control opacity and rotation of the View (it will curve away and fade down as it is dragged).
// 1. Add an @State property to track how far the card was dragged
// 2. Attach 3 modifiers to the CardView: if you offset and only then rotate the result will be different than if you rotate and then offset (you will get a different result because the "left" of the card has changed). When it comes to moving and rotating, we want the View to slide to the West regardless of the orientation it has while also rotating it. Therefore, we need to put the rotation then the offset.
// 2.1. We don't want to use the amount the user has dragged in rotation, otherwise the card would spin too quickly. Instead, we will apply 1/5 of it.
// 2.2. Next, we will apply our movement so the card slides relatively to the horizontal amount. Here, if we use the amount the user has dragged, we will need them to drag a long way to get a meaningful result. Instead, we will multiply it by 5 to improve speed.
// 2.3. We want the card to fade out as it is dragged away. We will take 1/50 of the drag amount so we get a really slow fade out. Then, we will put the drag amount inside abs(), because we don't care if the dragging was to the left (negative) or to the right (positive). Then, we will subtract the absolute value by 2, so the card stays opaque while being dragged a little bit (if you drag 50 points to the left or right it will start being transparent, until it reaches total transparency when dragged to 100 points left/right).

struct CardView: View {
    @State private var offset = CGSize.zero // No drag by default
    
    // We will hide the answer label by default and toggle its visibility whenever the card is tapped
    @State private var isShowingAnswer = false
    
    // Which card it is looking at
    let card: Card
    
    // A function that accepts no parameters and returns Void?
    // It is set to nil so we don't have to provide it unless it is really needed
    // We need this to remove cards without calling ContentView
    var removal: (() -> Void)? = nil
    
    var body: some View {
        ZStack {
            RoundedRectangle(cornerRadius: 25)
                .fill(.white) // Invisible in the Canvas, but this does matter on other screens
                // When we get a stack of cards, it will be problematic: since they are all white, they will kind of blend into each other on the screen. To solve this, add a shadow to the RoundedRectangle, so our white card will stand out against the white background. When we get a stack of cards, the shadows will be summed up.
                .shadow(radius: 10)
            
            VStack {
                Text(card.prompt)
                    .font(.largeTitle)
                    .foregroundStyle(.black) // Black is the default for Light Mode, but since this uses a white background it has to be black no matter what
                
                if isShowingAnswer {
                    Text(card.answer)
                        .font(.title)
                        .foregroundStyle(.secondary) // Slightly translucent/Grayish
                }
            }
            .padding(20) // Texts can't go to the very edge of the card
            .multilineTextAlignment(.center) // So everything aligns at the center
        }
        .frame(width: 450, height: 250) // The ZStack gets a precise size as well. This size is no accident: the smallest iPhones have a landscape width of abount 480 points, so this means our card is fully visible on all devices.
        .rotationEffect(.degrees(offset.width / 5.0)) // One fifth of the dragging speed will be applied on rotation
        .offset(x: offset.width * 5) // A bigger movement for a small gesture
        .opacity(2 - Double(abs(offset.width / 50)))
        // A Drag Gesture that updates the offset as the user is dragging around. Drag Gestures let us attach two functions to be ran: one for when the gesture is changed (called every time the user moves their finger) and another for when the gesture was ended (when the finger was lift off the screen). We will read the translation property to see where the user has dragged to (we could also have used the startLocation or the predictedEndLocation).
        // In the ended function, we will check if the card was moved 100 points in either direction, so we can prepare to remove the card. If they haven't, we will set offset to 0.
        .gesture(
            DragGesture()
                .onChanged { gesture in
                    offset = gesture.translation
                }
                .onEnded { _ in // Ignore the value coming in
                    if abs(offset.width) > 100 {
                        // Remove the card in the parent View
                        // We don't want CardView to call ContentView and manipulate this data directly. A much better idea is to store a closure parameter inside our CardView that can be filled with whatever code we want to run later on. This way, we create a callback in our ContentView without tying it with CardView.
                        removal?() // This closure is only called if it actually has a value.
                        // In ContentView, we will add a method to remove the card that will be conected to the removal closure.
                    } else {
                        // Let's not remove the card
                        offset = .zero
                    }
                }
        )
        
        // An .onTapGesture{} to toggle isShowingAnswer and reveal the answer.
        // In this instance, adding .onTapGesture{} works better than adding a Button, because we will add dragging as well and then solve the conflicts involving two gestures at the same time.
        .onTapGesture {
            isShowingAnswer.toggle()
        }
    }
}

#Preview {
    CardView(card: .example) // The example given inside Card.swift
}
